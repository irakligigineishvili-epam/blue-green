blue:
  conf:
    appName: blue
    tier: frontend
    environment: development
    version: "0.0.1"
  replicaCount: 2
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  image:
    repository: nginx
    tag: "1.29"
    pullPolicy: IfNotPresent
  serviceAccount:
    create: true
    name: "blue"
    automount: false
  podSecurityContext: {}
  securityContext: {}
  livenessProbe:
    httpGet:
      port: 80
    initialDelaySeconds: 5
    periodSeconds: 10
  readinessProbe:
    httpGet:
      port: 80
    initialDelaySeconds: 5
    periodSeconds: 10
  resources:
    requests:
      memory: "64Mi"
      cpu: "25m"
    limits:
      memory: "128Mi"
      cpu: "50m"
  service:
    type: ClusterIP
    port: 80
  ingress:
    enabled: true
    className: nginx
    hosts:
      - host: ""
        paths:
          - path: /blue
            pathType: Prefix
  nodeSelector: {}
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          - matchExpressions:
              - key: kubernetes.io/hostname
                operator: In
                values:
                  - minikube-m02
  tolerations: []
  topologySpreadConstraints:
    - maxSkew: 1
      minDomains: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: DoNotSchedule
      labelSelector:
        matchLabels:
          app.kubernetes.io/component: frontend
          app.kubernetes.io/instance: blue
          app.kubernetes.io/version: "0.0.1"
  autoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 5
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80
    behavior:
      enabled: false
  volumeMounts:
    - name: config-volume
      mountPath: /etc/nginx/conf.d
  volumes:
    - name: config-volume
      configMap:
        name: blue-config
        items:
          - key: nginx.conf
            path: nginx.conf
  configmap:
    create: true
    data:
      nginx.conf: |
        server {
          listen 80;
          server_name localhost;
          location / {
            return 200 "Blue!\n";
          }
        }
    binaryData: {}

green:
  conf:
    appName: green
    tier: frontend
    environment: develop
    version: "0.0.1"
  replicaCount: 2
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  image:
    repository: nginx
    tag: "1.29"
    pullPolicy: IfNotPresent
  serviceAccount:
    create: true
    name: "green"
    automount: false
  podSecurityContext: {}
  securityContext: {}
  livenessProbe:
    httpGet:
      port: 80
    initialDelaySeconds: 5
    periodSeconds: 10
  readinessProbe:
    httpGet:
      port: 80
    initialDelaySeconds: 5
    periodSeconds: 10
  resources:
    requests:
      memory: "64Mi"
      cpu: "25m"
    limits:
      memory: "128Mi"
      cpu: "50m"
  service:
    type: ClusterIP
    port: 80
  ingress:
    enabled: true
    className: nginx
    hosts:
      - host: ""
        paths:
          - path: /green
            pathType: Prefix
  nodeSelector: {}
  affinity: {}
  tolerations: []
  topologySpreadConstraints:
    - maxSkew: 2
      minDomains: 2
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: DoNotSchedule
      labelSelector:
        matchLabels:
          app.kubernetes.io/component: frontend
          app.kubernetes.io/instance: green
          app.kubernetes.io/version: "0.0.1"
  autoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 7
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80
    behavior:
      enabled: false
  volumeMounts:
    - name: config-volume
      mountPath: /etc/nginx/conf.d
  volumes:
    - name: config-volume
      configMap:
        name: green-config
        items:
          - key: nginx.conf
            path: nginx.conf
  configmap:
    create: true
    data:
      nginx.conf: |
        server {
          listen 80;
          server_name localhost;
          location / {
            return 200 "Green!\n";
          }
        }
    binaryData: {}
